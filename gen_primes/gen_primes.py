'''
    files generated by this tool are not considered a derivative work
    you can do whatever you wish with them.
'''
import os
import sys
import argparse
import subprocess
import re

def get_bitl_prime(nbits):
    p = subprocess.run(["./gen_primes", '{}'.format(nbits)], stdout=subprocess.PIPE)
    output = p.stdout.decode('utf-8')
    rs = re.search(r'(\d+)', output)
    if not rs:
        raise ValueError('{}\n{}'.format(n,output))
    num = int(rs.group(1))
    return num

parser = argparse.ArgumentParser(description='')
parser.add_argument('--bits', type=int, nargs=1, metavar='B', help='what bitness')
parser.add_argument('--tries', type=int, nargs=1, metavar='B', help='how many times should we try generating another number for each bit attempting to get a larger one')
parser.add_argument('--prefix', nargs=1, help='what func name prefix')
parser.add_argument('--mode', nargs=1, help='["values", "funcs", "switch", "switch_p"]')
parser.add_argument('--no-values', help='disable printing the array', action='store_true')
parser.add_argument('--no-ifndef', help='disable printing ifndef guard', action='store_true')
parser.add_argument('--decl-modifier', nargs=1, help='defaults to static')
with_values = True
with_ifndef = True
decl_modifier = 'static '


args = dict(vars(parser.parse_args()))
bits = 32
tries=1
if args['tries'] and args['tries'][0] > 1:
    tries = args['tries'][0]

if args['no_values']:
    with_values = False
if args['no_ifndef']:
    with_ifndef = False

if args['decl_modifier']:
    decl_modifier = args['decl_modifier'][0]

if len(decl_modifier) > 0 and (not decl_modifier.endswith(' ')):
    decl_modifier = decl_modifier + ' '

if args['bits']:
    if (args['bits'][0] < 4):
        print('unsupported n bits: ', args['bits'])
        sys.exit(1)
    bits = args['bits'][0]
prefix='adiv'
mode = 'values'
if args['mode']:
    if (args['mode'][0] not in ['values', 'funcs', 'switch', 'switch_p']):
        print('unsupported mode: ', args['mode'])
        sys.exit(1)
    mode = args['mode'][0]

def gen():
    bitl = 2
    lis = []
    for n in range(bitl, bits):
        max_found = 0
        for i in range(tries):
            prm = get_bitl_prime(n)
            prml = prm.bit_length()
            max_found = max(prm, max_found)
        assert(prml == n)
        lis.append(prm)
    return lis

generated = gen()

#int as str
def ias(num):
    if bits > 32:
        return '{}LLU'.format(num)
    else:
        return '{}LU'.format(num)
def itype():
    return 'uint32_t' if bits <= 32 else 'uint64_t'
def fptrtype_typedef_name():
    return '{}_fptr'.format(prefix)
def fptrtype_typedef():
    return 'typedef {int_type} (*{name})({int_type} dividend);'.format(int_type=itype(), name=fptrtype_typedef_name())
def fnam(nbits):
    return '{}_mod_{}'.format(prefix, nbits)

def mode_switch(values):
    values = list(values)
    func_name = '{pfx}_div'.format(pfx=prefix)
    print('/*returns dividened % divisor, assumes divisor is one of the hardcoded values*/')
    print('''{modifier}{int_type} {name}({int_type} dividened, {int_type} divisor) {{'''.format(int_type=itype(), name=func_name, modifier=decl_modifier))
    print('    switch (divisor) {')
    for i,v in enumerate(values):
        print('        case {}: return dividened % {}; break;'.format(ias(v), ias(v)))
    print('        default: exit(1); break; /*NOT FOUND*/')
    print('    }')
    print('    return 0; //unreachable')
    print('}')
def mode_switch_p(values):
    values = list(values)
    func_name = '{pfx}_div'.format(pfx=prefix)
    if not with_values:
        raise RuntimeError('generating this function would be meaningless without an array of values')
    print('/*returns dividened % divisor, divisor is {pfx}_values[power], which is a prime leq 2^power */'.format(pfx=prefix))
    print('''{modifier}{int_type} {name}({int_type} n, int power) {{'''.format(int_type=itype(), name=func_name, modifier=decl_modifier))
    print('    switch (power) {')
    for i,v in enumerate(values):
        print('        case {}: return n % {}; break;'.format(v.bit_length(), ias(v)))
    print('        default: exit(1); break; /*NOT FOUND*/')
    print('    }')
    print('    return 0; //unreachable')
    print('}')
def mode_funcs(values):
    values = list(values)
    funcl=[]
    err_name = fnam(0)
    print(fptrtype_typedef())
    print('''
{modifier}{int_type} {name}({int_type} dividend) {{
    /*ERROR FUNCTION*/
    exit(1);
    return 0;
}}
            '''.format(int_type=itype(), name=err_name, modifier=decl_modifier))
    #have array[0] and array[1] = err func (a sentinel)
    funcl.append(err_name)
    funcl.append(err_name)

    for i,v in enumerate(values):
        func_name = fnam(v.bit_length())
        print('''{modifier}{int_type} {name}({int_type} dividend) {{ return dividend % {divisor}; }} '''.format(int_type=itype(), name=func_name, divisor=v, modifier=decl_modifier))
        funcl.append(func_name)

    funcl.append(err_name) #sentinel at end

    print('{typedef} const {pfx}_funcs[] = {{'.format(typedef=fptrtype_typedef_name(),pfx=prefix))
    for i,v in enumerate(funcl):
        print('    {nam},'.format(nam=v))
    print('};\n')

    
    pass
def mode_values(values):
    values = list(values)
    #have array[0] and array[1] = 0 (a sentinel)
    values = [0, 0, *values]
    print('const {modifier}{int_type} {pfx}_n_values = {count};'.format(int_type=itype(), pfx=prefix, count=len(values), modifier=decl_modifier))
    print('const {modifier}{int_type} {pfx}_values[] = {{'.format(int_type=itype(), pfx=prefix, modifier=decl_modifier))
    lenline=0
    for i,v in enumerate(values):
        if (i > 0):
            print(', ', end='')
            lenline += 2
            if lenline > 75:
                print('\n    ', end='') 
                lenline = 0
        else:
            print('    ', end='')
        print(ias(v), end='')
        lenline += len(ias(v))

    print('\n};')

def ifndefbegin():
    if with_ifndef:
        print('''#ifndef {pfx}_H\n#define {pfx}_H\n#include <stdint.h>\n'''.format(pfx=prefix.upper()))
def ifndefend():
    if with_ifndef:
        print('''#endif /*{pfx}_H*/'''.format(pfx=prefix.upper()))

ifndefbegin()

if with_values:
    mode_values(generated)

if mode == 'funcs':
    mode_funcs(generated)
elif mode == 'switch':
    mode_switch(generated)
elif mode == 'switch_p':
    mode_switch_p(generated)

ifndefend()
